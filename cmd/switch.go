package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/no-yan/wt/internal"
	"github.com/spf13/cobra"
)

var switchCmd = &cobra.Command{
	Use:     "switch <name>",
	Aliases: []string{"sw"},
	Short:   "Switch to a worktree",
	Long: `Switch to a worktree by name. This command outputs the target path for shell integration.

For zsh integration, use the shell functions generated by 'wt shell-init'.`,
	Args: cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		target := args[0]

		runner := internal.NewExecCommandRunner()
		service := internal.NewGitService(runner)

		worktrees, err := service.ListWorktrees()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error listing worktrees: %v\n", err)
			os.Exit(1)
		}

		path, err := findWorktreeByName(worktrees, target)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)

			// Show available worktrees as suggestions
			if len(worktrees) > 0 {
				fmt.Fprintf(os.Stderr, "\nAvailable worktrees:\n")
				for _, wt := range worktrees {
					fmt.Fprintf(os.Stderr, "  %s\n", wt.Name())
				}
			}
			os.Exit(1)
		}

		// Output the path for shell integration
		fmt.Println(path)
	},
}

func findWorktreeByName(worktrees []internal.Worktree, target string) (string, error) {
	if len(worktrees) == 0 {
		return "", fmt.Errorf("no worktrees found")
	}

	target = strings.TrimSpace(target)
	if target == "" {
		return "", fmt.Errorf("target name cannot be empty")
	}

	for _, wt := range worktrees {
		if wt.Name() == target {
			return wt.Path, nil
		}
	}

	return "", fmt.Errorf("worktree %q not found", target)
}
